<!DOCTYPE html>
<html>
<head>
  <script>
    const DEFAULT_BG_COLOR = '#25689575';
    const DEFAULT_COLOR = '#ffffff';
    const TRENDS_DEFAULT_BG_COLOR = '#ff00005c';
    const TRENDS_DEFAULT_COLOR = '#ffffff';

    const CONFIG_SCRIPT = {
      intervalWait: 1000, // wait time between requests to retrieve data
      historyBuffer: 200, // number of items to retrieve in limit for metric.history
      dateFormat: 'en-us', // javascript options
      timeFormat: 'en-us' // javascript options
    }

    const CONFIG = [
      {
        objecttype: 'cdpparking',
        backgroundcolor: '#0031ff75',
        color: DEFAULT_COLOR,
        imagesrc: '/proxy/file/resource/parking01.png',
        title: 'Parking',
        // trends: [
        // { type: 'line', metric: 'column1' },
        // { type: 'bar', metric: 'column1' },
        // ],
        // trendsbackgroundcolor: TRENDS_DEFAULT_BG_COLOR,
        // trendscolor: TRENDS_DEFAULT_COLOR,
      },
      {
        objecttype: 'cdplights',
        backgroundcolor: '#ffc40075',
        color: DEFAULT_COLOR,
        imagesrc: '/proxy/file/resource/light01.png',
        title: 'Lighting',
        // trends: [
        // { type: 'line', metric: 'column1' },
        // { type: 'bar', metric: 'column1' },
        // ],
        // trendsbackgroundcolor: TRENDS_DEFAULT_BG_COLOR,
        // trendscolor: TRENDS_DEFAULT_COLOR,
      },
      {
        objecttype: 'cdpenv',
        backgroundcolor: '#1fbd2f75',
        color: DEFAULT_COLOR,
        imagesrc: '/proxy/file/resource/env01.png',
        title: 'Env',
        // trends: [
        // { type: 'line', metric: 'column1' },
        // { type: 'bar', metric: 'column1' },
        // ],
        // trendsbackgroundcolor: TRENDS_DEFAULT_BG_COLOR,
        // trendscolor: TRENDS_DEFAULT_COLOR,
      },

      // {
      //   objectnames: 'marker5,marker7', // no spaces
      //   backgroundcolor: '#80809575',
      //   color: DEFAULT_COLOR,
      //   imagesrc: '/proxy/file/resource/big-o.png',
      //   title: 'Markers 5 & 7',
      // },
      // {
      //   objectname: 'marker8', // no spaces
      //   backgroundcolor: '#98652375',
      //   color: DEFAULT_COLOR,
      //   imagesrc: '/proxy/file/resource/big-o.png',
      //   alerts: true,
      //   alertheader: 'column2',
      //   title: 'Alerts',
      // },
    ]


  </script>
  <!-- buttons style -->
  <style>
    :root {
      --triangle-color: #00000098;
    }
    body {
      height: 100%;
      margin: 0;
      font-size: 16px;
      overflow: hidden;
      font-family: Arial, Tahoma;
      line-height: 1.5;
      padding-top: 5px;
    }
    #image-buttons-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .image {
      flex: 1 1 5%;
      text-align: center;
      position: relative;
      cursor: pointer;
      height: 40px;
    }
    #image-buttons-container img {
      max-width: 100%;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      margin-bottom: 1rem;
    }
    div.selected span::after {
      position: absolute;
      content: '';
      border: 10px solid transparent;
      border-top: 10px solid var(--triangle-color);
      left: 50%;
      transform: translateX(-50%);
      bottom: -20px;
    }
    #main-container {
      position: absolute;
      background: #25689575;
      height: 100%;
      width: 100%;
      margin-top: 15px;
    }
    #panel {
      height: calc(100% - 160px);
      width: 100%;
      overflow: auto;
    }
    #search {
      width: 90%;
      display: block;
      margin: 10px auto;
    }
    #search input {
      width: calc(100% - .8rem);
      border-radius: .2rem;
      border: none;
      padding: .4rem;
    }
    #loading-spinner {
      position: absolute;
      top: 45%;
      left: 50%;
      transform: translateX(-50%);
    }
    .metric-container.hide-children  .metrics {
      display: none;
    }
    .metric-container {
      margin: .1rem 0 0 0;
      cursor: pointer;
    }
    .metric-main {
      padding: .4rem;
      flex-wrap: wrap;
      word-break: break-all;
    }
    .flex-me {
      display: flex;
      justify-content: space-between;
    }
    .location {
      width: 25px;
      height: 25px;
      font-size: 1.5em;
      display: flex;
      justify-content: center;
      border-radius: 50px;
    }
    .location:after {
      content: '\021A9';
    }
    .metric-object-name,
    .metric-health {
      padding: .2rem 0;
    }
    .metric-object-name {
      flex: 0 0 75%;
    }
    .metric-health {
      flex: 0 0 25%;
    }
    .metric-trend {
      text-align: center;
      margin-top: .2rem;
      padding: 0.3rem;
    }
    .metric-main-sub {
      font-size: 0.7rem;
      padding: .1rem .4rem;
    }
    .metric > div {
      padding: .2rem 0;
    }
    .metric > div:first-child {
      margin-right: .4rem;
    }
    .timestamp {
      font-size: 0.7rem;
      margin-top: .2rem;
    }
    .metric {
      padding: 0 .8rem;
      display: flex;
      justify-content: space-between;
      font-size: .8rem;
      position: relative;
    }
    .metric-child {
      display: block !important;
    }
    .metric > .metric {
      margin-left: .4rem;
    }
    .metric > div {
      line-height: 1.3;
    }
    .metric.metric-image {
      flex-direction: column;
      align-items: center;
    }
    .metric-main.metrics-hidden ~ .metric {
      display: none;
    }
    .metric .click-to-load {
      right: 0;
      position: absolute;
      top: 50%;
      left: 0;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }
    .hidden {
      display: none;
    }
  </style>


</head>
<body id="body">
  <div id="image-buttons-container"></div>

  <div id="main-container">
    <div id="search">
      <input type="text" oninput="searchIt(this)" placeholder="Search..." />
    </div>


    <div id="title" style="padding: 0 .4rem"></div>


    <div id="panel">
      <div id="loading-spinner">
        <!-- base64 loading spinner -->
        <img src="data:image/svg+xml;charset=utf-8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjAiIHdpZHRoPSI2NHB4IiBoZWlnaHQ9IjY0cHgiIHZpZXdCb3g9IjAgMCAxMjggMTI4IiB4bWw6c3BhY2U9InByZXNlcnZlIj48Zz48cGF0aCBkPSJNNzEgMzkuMlYuNGE2My42IDYzLjYgMCAwIDEgMzMuOTYgMTQuNTdMNzcuNjggNDIuMjRhMjUuNTMgMjUuNTMgMCAwIDAtNi43LTMuMDN6IiBmaWxsPSIjMDAwIi8+PHBhdGggZD0iTTcxIDM5LjJWLjRhNjMuNiA2My42IDAgMCAxIDMzLjk2IDE0LjU3TDc3LjY4IDQyLjI0YTI1LjUzIDI1LjUzIDAgMCAwLTYuNy0zLjAzeiIgZmlsbD0iI2UxZTFlMSIgdHJhbnNmb3JtPSJyb3RhdGUoNDUgNjQgNjQpIi8+PHBhdGggZD0iTTcxIDM5LjJWLjRhNjMuNiA2My42IDAgMCAxIDMzLjk2IDE0LjU3TDc3LjY4IDQyLjI0YTI1LjUzIDI1LjUzIDAgMCAwLTYuNy0zLjAzeiIgZmlsbD0iI2UxZTFlMSIgdHJhbnNmb3JtPSJyb3RhdGUoOTAgNjQgNjQpIi8+PHBhdGggZD0iTTcxIDM5LjJWLjRhNjMuNiA2My42IDAgMCAxIDMzLjk2IDE0LjU3TDc3LjY4IDQyLjI0YTI1LjUzIDI1LjUzIDAgMCAwLTYuNy0zLjAzeiIgZmlsbD0iI2UxZTFlMSIgdHJhbnNmb3JtPSJyb3RhdGUoMTM1IDY0IDY0KSIvPjxwYXRoIGQ9Ik03MSAzOS4yVi40YTYzLjYgNjMuNiAwIDAgMSAzMy45NiAxNC41N0w3Ny42OCA0Mi4yNGEyNS41MyAyNS41MyAwIDAgMC02LjctMy4wM3oiIGZpbGw9IiNiZWJlYmUiIHRyYW5zZm9ybT0icm90YXRlKDE4MCA2NCA2NCkiLz48cGF0aCBkPSJNNzEgMzkuMlYuNGE2My42IDYzLjYgMCAwIDEgMzMuOTYgMTQuNTdMNzcuNjggNDIuMjRhMjUuNTMgMjUuNTMgMCAwIDAtNi43LTMuMDN6IiBmaWxsPSIjOTc5Nzk3IiB0cmFuc2Zvcm09InJvdGF0ZSgyMjUgNjQgNjQpIi8+PHBhdGggZD0iTTcxIDM5LjJWLjRhNjMuNiA2My42IDAgMCAxIDMzLjk2IDE0LjU3TDc3LjY4IDQyLjI0YTI1LjUzIDI1LjUzIDAgMCAwLTYuNy0zLjAzeiIgZmlsbD0iIzZlNmU2ZSIgdHJhbnNmb3JtPSJyb3RhdGUoMjcwIDY0IDY0KSIvPjxwYXRoIGQ9Ik03MSAzOS4yVi40YTYzLjYgNjMuNiAwIDAgMSAzMy45NiAxNC41N0w3Ny42OCA0Mi4yNGEyNS41MyAyNS41MyAwIDAgMC02LjctMy4wM3oiIGZpbGw9IiMzYzNjM2MiIHRyYW5zZm9ybT0icm90YXRlKDMxNSA2NCA2NCkiLz48YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgdmFsdWVzPSIwIDY0IDY0OzQ1IDY0IDY0OzkwIDY0IDY0OzEzNSA2NCA2NDsxODAgNjQgNjQ7MjI1IDY0IDY0OzI3MCA2NCA2NDszMTUgNjQgNjQiIGNhbGNNb2RlPSJkaXNjcmV0ZSIgZHVyPSI3MjBtcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT48L2c+PGc+PGNpcmNsZSBmaWxsPSIjMDAwIiBjeD0iNjMuNjYiIGN5PSI2My4xNiIgcj0iMTIiLz48YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiBkdXI9IjcyMG1zIiBiZWdpbj0iMHMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBrZXlUaW1lcz0iMDswLjU7MSIgdmFsdWVzPSIxOzA7MSIvPjwvZz48L3N2Zz4=" />
      </div>
      <!-- place error messages in here -->
      <div id="errors"></div>
      <div id="object-types-container"></div>
      <div id="map-player"></div>
    </div>
  </div>



  <!-- buttons script -->
  <script>
    // use config to place buttons in DOM
    let buttonsHtml = "";
    for (let i = 0; i < CONFIG.length; i++) {
      buttonsHtml += `<div class="image ${i === 0 ? 'selected' : ''}" data-configindex="${i}"`
      for (let key in CONFIG[i]) {
        buttonsHtml += `
            data-${key}="${CONFIG[i][key]}"
          `
      }
      buttonsHtml += `
          >
            <span>
              <img src="${CONFIG[i].imagesrc}" />
            </span>
          </div>
        `
    }
    // all buttonsHtml to DOM
    let imageButtonsContainerEl = document.getElementById('image-buttons-container');
    imageButtonsContainerEl.innerHTML = buttonsHtml;


    // add click listener that fires an event when the objecttype button is selected
    let imageEls = document.getElementsByClassName('image');
    for (let i = 0; i < imageEls.length; i++) {
      // attach event listener
      imageEls[i].addEventListener('click', function (evt) {
        // when clicked remove selected from all imageEls,
        for (let j = 0; j < imageEls.length; j++) {
          if (imageEls[j].classList.contains('selected')) {
            imageEls[j].classList.remove('selected');
          }
        }
        // add selected to the imageEl that was selected
        this.classList.add('selected');
        // fire an event for all listeners with information regarding
        // objecttype and other params
        let obj = {}
        for (let key in evt.currentTarget.dataset) {
          obj[key] = evt.currentTarget.dataset[key];
        }
        fireEvent(obj)
      });
    }


    // fires off an event letting everyone know which button was
    // clicked
    function fireEvent(obj) {
      let event = new CustomEvent('panel-button-fire', {
        detail: obj
      });
      document.dispatchEvent(event);
    }

    // need to fire off an event choosing the first item in config,
    // otherwise nothing will be shown on the initial load
    window.onload = function () {
      imageEls[0].click();
    };
  </script>



  <!-- panel body script -->
  <script>
    let { frameElement: { contentWindow : { parent = {} } = {} } = {} } = window;
    let objectType = "";
    let oldObjectType = "";
    let objectName = "";
    let objectNames = [];
    let objects = [];
    let metrics = {};
    let searchValue = "";
    let configIndex = null;
    let bgColor = "";

    // search bar
    function searchIt(event = {}) {
      let { value = "" } = event;
      searchValue = value;
      let els = document.getElementsByClassName('metric-container');
      for (let i = 0; i < els.length; i++) {
        let passesTest = els[i].dataset.id.toLowerCase().indexOf(value.toLowerCase()) > -1 ? true : false;
        if (!passesTest) {
          els[i].classList.add('hidden');
        } else {
          els[i].classList.remove('hidden');
        }
      }
    }


    // remove hidden from metric-container
    function showMetricContainer(el, event) {
      event.stopPropagation();
      el.parentElement.classList.toggle('hide-children');
    }


    // listen for object type event
    document.addEventListener('panel-button-fire', function(evt = {}) {
      let { detail = {} } = evt;
      // if already the selected objectType, just return
      if (detail.objecttype == objectType) return;
      // set the oldObjectType to what is currently set as objectType because we are going to
      // set the objectType right now
      oldObjectType = objectType;
      if (detail.objecttype) {
        objectType = detail.objecttype;
      } else if (detail.objectnames) {
        objectType = detail.objectnames;
        objectNames = detail.objectnames.split(',');
        objectName = detail.objectnames;
      } else if (detail.objectname) {
        objectType = detail.objectname;
        objectNames = [detail.objectname];
        objectName = detail.objectname;
      }
      // the button has a config index data attribute that we can use to tell where
      // the
      configIndex = detail.configindex;
      // get all objects for that objectType
      // get metrics from current metrics object if already exists,
      // otherwise go get the metrics
      if (objectType === oldObjectType) {
        return;
      }
      bgColor = detail.backgroundcolor;
      // change background and font color based on config
      changeColors(bgColor, detail.color);
      // change header/title based on headerinfo field in config
      if (detail.title) {
        changeTitle(detail.title, bgColor, detail.color);
      }
      insertHtml('object-types-container', '');
      toggleLoadingSpinner(true);
      if (metrics[objectType] && metrics[objectType].singleObject) {
        compareMetrics(metrics[objectType], metrics[objectType], objectType, true);
      } else if (metrics[objectType]) {
        compareMetrics(metrics[objectType], metrics[objectType], objectType);
      } else if (detail.objecttype) {
        getObjectsByType(detail.objecttype);
      } else if (detail.objectnames) {
        // use first objectName as objectTypeName when using 'object1, object2' format
        getObjectMetrics(objectNames, objectType);
      } else if (detail.objectname) {
        getObjectMetrics(objectNames, objectType, CONFIG_SCRIPT.historyBuffer);
      }
    });


    function changeColors(bgColor = "#00000085", fontColor = "#ffffff") {
      let mainEl = document.getElementById('main-container');
      mainEl.style.backgroundColor = changeColorShade(bgColor, 95);
      mainEl.style.color = fontColor;
    }


    function changeColorShade(bgColor = "#00000085", adder = 85) {
      return bgColor.substring(0, 7) + adder;
    }


    // changes the title based on headerinfo config property
    function changeTitle(title = "", bgColor = "#00000085", fontColor = "#ffffff") {
      let el = document.getElementById('title');
      el.style.backgroundColor = changeColorShade(bgColor, 98);
      el.innerHTML = `<h2 style="margin: 4px 0; padding: 6px 0; text-transform: capitalize;">${title}</h2>`;
    }


    // get objects by object type
    function getObjectsByType(ObjectTypeName = null) {
      if (!ObjectTypeName) return null;
      let objectTypeList = parent.n.call('object.list', { query: { ObjectTypeName } }, (err, res = {}) => {
        if (err) {
          return createError("Failed to retrieve the object list by type. Please try reselecting the object type button.");
        }
        // just get the object names and store in an array
        objects = res.body.map(obj => {
          return obj.Name;
        });
        // get the metrics for the list of objects
        getObjectMetrics(objects, ObjectTypeName);
      });
    }


    // get object metrics
    function getObjectMetrics(ObjectNames = [], objectTypeName = "", limit = 1) {
      let objType = objectType;
      parent.n.call('metric.history', { ObjectName: ObjectNames, Begin: 1, End: Date.now(), Limit: limit }, (err, res = {}) => {
        if (err) {
          return createError("Failed to retrieve object metrics. Please try reselecting the object type button.");
        }
        // if the user has clicked to another objectType, just cancel the request
        if (objType !== objectTypeName) return;
        if (limit === 1) {
          compareMetrics(metrics[objectTypeName], res.body, objectTypeName);
        } else {
          compareMetrics(metrics[objectTypeName], res.body, objectTypeName, true);
        }
        startSetInterval();
      });
    }


    // compare metrics and create a new metrics html section
    // and attach it in place of the old html
    function compareMetrics(oldMetrics = {}, newMetrics = {}, objectTypeName = "", singleObject = false) {
      let previousKey = "";
      let previousTimestamp = "";
      let doNotInsert = true;
      let html = "";
      metrics[objectTypeName] = newMetrics;
      if (singleObject && metrics[objectTypeName]) {
        metrics[objectTypeName].singleObject = true;
      }
      let objectNameKeys = Object.keys(newMetrics);
      objectNameKeys.sort();
      for (let key of objectNameKeys) {
        let newMetricsTimestamp = Object.keys(newMetrics[key]);
        let oldMetricsTimestamp = [];
        if (newMetricsTimestamp.length === 0) continue;
        if (oldMetrics[key]) {
          oldMetricsTimestamp = Object.keys(oldMetrics[key]);
        }
        if (objectType !== objectTypeName) return;
        // if we're looking at a single object, then we need the history for that single object,
        // not just the last metric
        if (singleObject) {
          for (let i = newMetricsTimestamp.length - 1; i >= 0; i--) {
            let timestamp = newMetricsTimestamp[i];
            if (timestamp === "singleObject") continue;
            if (oldObjectType != objectTypeName) {
              html += createSingleObjectListHtml(newMetrics[key][timestamp])
              continue;
            }
            // if the metrics are the same, only change that metric container
            html = createSingleObjectListHtml(newMetrics[key][timestamp])
            // if the element already exists, insert into existing dom element
            // else if it doesn't append after previousKey, so we retain the order
            let currentEl = document.getElementById(timestamp);
            if (currentEl) {
              insertOuterHtml(timestamp, html);
              if (!currentEl.classList.contains('hide-children')) {
                currentEl = document.getElementById(timestamp);
                currentEl.classList.remove('hide-children');
              }
            } else {
              let el = document.getElementById('object-types-container');
              el.innerHTML = html + el.innerHTML;
            }
            doNotInsert = false;
            previousTimestamp = timestamp;
          }
          continue;
        }
        if (oldObjectType != objectTypeName) {
          html += createObjectListHtml(newMetrics[key][newMetricsTimestamp[newMetricsTimestamp.length - 1]])
          continue;
        } else if (newMetricsTimestamp[newMetricsTimestamp.length - 1] !== oldMetricsTimestamp[oldMetricsTimestamp.length - 1]) {
          // if the metrics are the same, only change that metric container
          html = createObjectListHtml(newMetrics[key][newMetricsTimestamp[newMetricsTimestamp.length - 1]])
          // if the element already exists, insert into existing dom element
          // else if it doesn't append after previousKey, so we retain the order
          let currentEl = document.getElementById(key);
          if (currentEl) {
            insertOuterHtml(key, html);
            if (!currentEl.classList.contains('hide-children')) {
              currentEl = document.getElementById(key);
              currentEl.classList.remove('hide-children');
            }
          } else {
            let el = document.getElementById(previousKey);
            if (el) {
              el.insertAdjacentHTML('afterend', html);
            }
          }
        }
        doNotInsert = false;
        previousKey = Object.keys(newMetrics[key]).length > 0 ? key : previousKey;
      }
      oldObjectType = objectTypeName;
      if (doNotInsert) {
        insertHtml('object-types-container', html);
      }
    }


    // object type list html
    function createObjectListHtml(data = {}, singleObject = false) {
      let html = "";
      let { value = {} } = data;
      let mainColor = changeColorShade(bgColor, 85);
      // need to check if searchValue is contained in name, so that we don't show if it's not
      html += `
        <div
          id="${data.objectinfo.name}"
          class="metric-container hide-children ${data.objectinfo.name.toLowerCase().indexOf(searchValue.toLowerCase()) > -1 ? '' : 'hidden'}"
          data-id="${data.objectinfo.name.toLowerCase()}"
        >
      `
        html += createMetricsHtml(value, data.objectinfo.name, data.health, mainColor);
      html += `</div>`;
      return html;
    }


    // object type list html for a single object
    function createSingleObjectListHtml(data = {}) {
      let html = "";
      let { value = {} } = data;
      let mainColor = changeColorShade(bgColor, 85);
      // need to check if searchValue is contained in name, so that we don't show if it's not
      html += `
        <div
          id="${data.meta.timestamp}"
          class="metric-container hide-children ${data.objectinfo.name.toLowerCase().indexOf(searchValue.toLowerCase()) > -1 ? '' : 'hidden'}"
          data-id="${data.objectinfo.name.toLowerCase()}"
        >
      `
        html += createSingleMetricsHtml(value, data.meta ? data.meta.timestamp : data.objectinfo.name, data.health, mainColor);
      html += `</div>`;
      return html;
    }



    // object metrics html
    function createMetricsHtml(values = {}, objectName = "", health = "", mainColor) {
      let html = `
        <div
          class="metric-main"
          style="background: ${mainColor};"
          onclick="var event = arguments[0] || window.event; showMetricContainer(this, event)"
        >
          <div class="flex-me">
            <div class="metric-object-name">${objectName}</div>
            <div class="metric-health">${health}</div>
          </div>`;
          if (values["latitude"] && values["longitude"] || values["Latitude"] && values["Longitude"]) {
            html += `
              <div class="metric-main-sub flex-me">
                <div class="coordinates-container">
                  <div class="coordinates">Latitude: ${values["latitude"] || values["Latitude"]}</div>
                  <div class="coordinates">Longitude: ${values["longitude"] || values["Longitude"]}</div>
                </div>
                <div
                  class="location"
                  style="background:${changeColorShade(mainColor, 99)}"
                  data-latitude="${values["latitude"] || values["Latitude"]}"
                  data-longitude="${values["longitude"] || values["Longitude"]}"
                  onclick="var event = arguments[0] || window.event; goToOnMap(this, event)"
                ></div>
              </div>`
          }
        html += `</div>`;
        html += `<div class="metrics">`;
          html += loopThroughMetrics(values);
          if (CONFIG[configIndex] && CONFIG[configIndex]["trends"] && CONFIG[configIndex]["trends"].length > 0) {
            html += `
              <div
                class="metric-trend"
                data-id="${objectName}"
                onclick="var event = arguments[0] || window.event; getHistory(this, event, ${CONFIG["trends"]})"
                style="background: ${CONFIG[configIndex]["trendsbackgroundcolor"] || '#ff00005c'}; color: ${CONFIG[configIndex]["trendscolor"] || '#ff00005c'};"
              >
                Trends
              </div>
            `
          }
      html += `</div>`;
      return html;
    }


    // create metrics for a single object
    function createSingleMetricsHtml(values = {}, time, health = "", mainColor) {
      let date = new Date(time);
      let alertHeader = CONFIG[configIndex].alertheader;
      let html = `
        <div
          class="metric-main"
          style="background: ${mainColor};"
          onclick="var event = arguments[0] || window.event; showMetricContainer(this, event)"
        >
          <div class="metric-object-name">
            ${alertHeader ? '<span>' + values[alertHeader] + '</span>' : ''}
          </div>
          <div class="metric-health">${health}</div>
          <span class="timestamp">${date.toLocaleDateString(CONFIG_SCRIPT.dateFormat)} ${date.toLocaleTimeString(CONFIG_SCRIPT.timeFormat)}</span>
        </div>
        <div class="metrics">
      `;
          html += loopThroughMetrics(values);
      html += `
        </div>
      `;
      return html;
    }


    function loopThroughMetrics(values = {}, html = "", isChild = null) {
      if (Array.isArray(values)) {
        for (let [key, value] of values.entries()) {
          let isImage = valueTypeIsImage(value);
          let isRtsp = !isImage ? valueTypeIsRtsp(value) : false;
          let isVideo = !isImage && !isRtsp ? valueTypeIsVideo(value) : false;
          let isAboveType = isImage || isRtsp || isVideo;
          html += `
            <div
              class="metric ${isImage ? 'metric-image' : ''} ${typeof value === "object" ? 'metric-child' : ''}"
              data-id="${objectName}"
              style="display: ${isAboveType ? "block" : "flex"}; ${isAboveType ? 'text-align: center' : ''}"
            >`
          // if it's an image use the image
          html += innerMetricHtml(key, value, isImage, isVideo, isRtsp);
          html += `</div>`
        }
        return html;
      } else {
        for (let key in values) {
          if (key.toLowerCase() === "latitude" || key.toLowerCase() === "longitude") continue;
          let value = values[key];
          let isImage = valueTypeIsImage(value);
          let isRtsp = !isImage ? valueTypeIsRtsp(value) : false;
          let isVideo = !isImage && !isRtsp ? valueTypeIsVideo(value) : false;
          let isAboveType = isImage || isRtsp || isVideo;
          html += `
            <div
              class="metric ${isImage ? 'metric-image' : ''}  ${typeof value === "object" ? 'metric-child' : ''}"
              data-id="${objectName}"
              style="display: ${isAboveType ? "block" : "flex"}; ${isAboveType ? 'text-align: center' : ''}"
            >`
          // if it's an image use the image
          html += innerMetricHtml(key, value, isImage, isVideo, isRtsp);
          html += `</div>`
        }
        return html;
      }
    }


    // check to see if value is an image
    function valueTypeIsImage(value) {
      let isImage = /\.(jpeg|jpg|gif|png)$/.test(String(value));
      let isBase64 = /^data:image.*base64/.test(String(value));
      return isImage || isBase64;
    }


    // check to see if value is video
    function valueTypeIsVideo(value) {
      return /\.(webm|ogg|mp4|mp3|wav|avi|m4a|m4v|mov|3gp|mkv|ogv|ogm|oga)$/.test(String(value));
    }


    // check to see if it's previousTimestamp
    function valueTypeIsRtsp(value) {
      return /^rtsp.*(webm|ogg|mp4|mp3|wav|avi|m4a|m4v|mov|3gp|mkv|ogv|ogm|oga)$/.test(String(value));
    }


    // check if is image and return proper html
    function innerMetricHtml(key, value, isImage = false, isVideo = false, isRtsp = false) {
      let html = '';
      if (!Array.isArray(value) && typeof key !== "number") {
        html += `
          <div>${key}</div>
        `;
      }
      if (typeof value === "object") {
          return loopThroughMetrics(value, html, true);
      }
      if (isImage) {
        html += `
          <img src="${value}" style="max-width: 100%" />
        `;
      } else if (isVideo) {
        html += `
          <video controls style="max-width: 100%">
            <source src="${value}">
            Your browser does not support this video type
          </video>
        `;
      } else if (isRtsp) {
        html += `
          <img
            class="rtsp-box"
            id="${Math.random() * key.length + '-' + Math.random() * key.length}"
            src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAEElEQVR42mOsXXF0NsMwAAD1hgKHDhZICwAAAABJRU5ErkJggg=="
            onclick="var event = arguments[0] || window.event; startVideo(this, event)"
            style="width: 100%; min-height: 75px;"
          />
          <div class="click-to-load">Please click to load video</div>
        `;
      } else {
        html += `
          <div>${value}</div>
        `;
      }
      return html;
    }

    // get the days worth of history to show on the table
    function getHistory(el = {}, event = {}) {
      event.stopPropagation();
      let objectName = event.currentTarget.dataset.id;
      let now = new Date();
      // set to beginning of day
      let begin = now.setHours(0, 0, 0, 0);
      begin -= 604800000; // 1 week in ms
      parent.n.call('metric.trend', { objectName, begin , end: Date.now(), fields: 'column2', limit: 500 }, (err, res) => {
        if (err) {
          console.log(err);
        }
        // TODO: create a graph here ***********************************
        console.log(res.body);
      });
    }


    // show chart based on data received
    function showChart(data) {
      // TODO: chart
    }


    // zoom into location on maps
    function goToOnMap(context, event) {
      event.stopPropagation();
      let { latitude, longitude } = context.dataset;
      window.frameElement._map.setView({ lat: latitude, lng: longitude }, 200);
    }


    // if there's an error, show in panel
    function createError(message) {
      let el = document.getElementById('errors');
      let html = `<div>${message}</div>`;
      insertHtml(el, html);
    }


    // attach html
    function insertHtml(elementId = "", html = "") {
      toggleLoadingSpinner(false);
      let el = document.getElementById(elementId);
      el.innerHTML = html;
    }


    // attach html
    function insertOuterHtml(elementId = "", html = "") {
      toggleLoadingSpinner(false);
      let el = document.getElementById(elementId);
      el.outerHTML = html;
    }


    // append html
    function appendHtml(elementId = "", html = "") {
      toggleLoadingSpinner(false);
      let el = document.getElementById(elementId);
      el.innerHTML += html;
    }


    function toggleLoadingSpinner(on = false) {
      let el = document.getElementById('loading-spinner');
      if (on === false) {
        el.classList.add('hidden');
      } else {
        el.classList.remove('hidden');
      }
    }


    // kick off setInterval to getObjectsByType every n seconds
    function startSetInterval() {
      if (objectName === objectType && objectNames.length > 1) {
        getObjectMetrics(objectNames, objectType)
      } else if (objectName === objectType) {
        getObjectMetrics(objectNames, objectType, CONFIG_SCRIPT.historyBuffer)
      } else {
        getObjectsByType(objectType);
      }
    }



  </script>
</body>
</html>
